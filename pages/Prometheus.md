- **Prometheus: Fundamentals of Monitoring**
	- **Definition**:
		- **Prometheus** is an open-source monitoring and alerting toolkit, originally developed at SoundCloud.
		- It provides a multi-dimensional data model, real-time metrics collection, flexible querying, and alerting.
		- Commonly used in environments with **microservices**, [[Kubernetes]] clusters, and #Docker-based workloads.
	- **Why Prometheus?**
		- **Time-Series Database (TSDB)**:
			- Prometheus stores all metrics as time-series data, identified by metric names and key-value pairs (labels).
			- This structure facilitates detailed and flexible querying of metrics over time.
		- **Pull-Based Model**:
			- Prometheus scrapes (pulls) metrics from targets (e.g., application endpoints, exporters).
			- Simplifies architecture in dynamic environments like [[Kubernetes]], where endpoints may frequently change.
		- **Highly Scalable**:
			- Designed for cloud-native scaling.
			- Can handle large volumes of metrics, especially when sharded or federated across multiple Prometheus servers.
		- **Powerful Query Language (PromQL)**:
			- PromQL lets you filter, aggregate, and evaluate time-series data in real-time.
			- Enables advanced dashboarding and alerting scenarios.
	- **Core Components**:
		- 1. **Prometheus Server**:
			- Scrapes metrics from configured targets.
			- Stores data locally in a time-series database.
			- Executes alerts based on PromQL expressions.
		- 2. **Exporters**:
			- Collect and expose metrics for various systems (e.g., **Node Exporter** for Linux, CPU/memory stats).
			- Allows monitoring of databases, caches, or even custom applications.
		- 3. **Alertmanager**:
			- Handles alerts generated by the Prometheus server.
			- Routes alerts to different channels (e.g., #Slack, Email, PagerDuty).
			- Supports grouping, silencing, and inhibition rules.
		- 4. **PromQL**:
			- Query language used to select and aggregate time-series data.
			- Example: `sum(rate(http_requests_total[5m]))` aggregates HTTP requests over the last 5 minutes.
		- 5. **Service Discovery**:
			- Integrates with platforms like [[Kubernetes]], [[Docker]] Swarm, [[AWS]], or static configurations.
			- Dynamically updates scrape targets as services come and go.
	- **Metrics Collection Flow**:
		- 1. **Application/Exporter**:
			- An application or exporter exposes metrics via HTTP endpoint (e.g., `:9100/metrics`).
		- 2. **Prometheus Server**:
			- Scrapes these metrics at configured intervals.
		- 3. **Local TSDB**:
			- Metrics are stored in Prometheus’s local time-series database.
		- 4. **PromQL**:
			- Users query stored metrics for dashboards, troubleshooting, or capacity planning.
		- 5. **Alertmanager**:
			- If queries match alerting rules, alerts are routed to on-call systems or #Slack.
	- **Deployment & Integration**:
		- **Stand-Alone Deployment**:
			- Install binaries in a VM or bare-metal environment.
			- Configure `prometheus.yml` for scrape targets.
			- Good for smaller on-prem or single-cloud use cases.
		- **Containerized**:
			- Run in #Docker or #Podman, specifying `prometheus.yml` via a volume.
			- Easy to incorporate into [[Kubernetes]] using Helm charts or operator-based deployment.
		- **High Availability**:
			- Run multiple Prometheus servers with identical scrape configs for redundancy.
			- Use external storage or remote-write solutions for long-term data retention.
		- **Integration with #Grafana**:
			- Grafana is a popular dashboarding tool that can query Prometheus and visualize data in real-time.
			- Typically used together for advanced data visualization.
	- **Use Cases**:
		- **Infrastructure Monitoring**: CPU, memory, disk, network for servers and VMs.
		- **Application Performance Monitoring (APM)**: Request latencies, error rates, concurrency levels.
		- **Microservices**:
			- Each service can expose custom metrics to track performance or business-related KPIs.
		- **[[Kubernetes]]**:
			- Monitor cluster health (nodes, pods, deployments, etc.) using the **kube-state-metrics** and **cAdvisor** exporters.
		- **Alerting**:
			- Automate notifications for critical conditions (e.g., high CPU usage, error spikes).
			- Integrate with #Slack, Email, or PagerDuty to handle on-call escalations.
	- **Basic Configuration Example** (simplified `prometheus.yml`):
	  ```yaml
	  global:
	    scrape_interval: 15s
	    evaluation_interval: 15s
	  
	  scrape_configs:
	    - job_name: 'node_exporter'
	      static_configs:
	        - targets: ['192.168.1.10:9100']
	    - job_name: 'my_app'
	      static_configs:
	        - targets: ['192.168.1.20:8080']
	  ```
		- **`scrape_interval`**: Frequency of scraping targets.
		- **`evaluation_interval`**: Frequency of evaluating alert rules.
		- **`scrape_configs`**: Lists each scrape target (job).
	- **Tips & Best Practices**:
		- **Use Labels Wisely**: Metrics are key-value pairs—avoid label bloat that can cause performance issues.
		- **Alert Tuning**: Set realistic thresholds to avoid alert fatigue. Group or route alerts meaningfully in Alertmanager.
		- **Record Rules**: Precompute frequently queried metrics to reduce PromQL load at query time.
		- **Retention & Storage**:
			- By default, Prometheus stores data locally, which might not be suitable for long-term retention.
			- Consider a remote storage adapter or solutions like Thanos, Cortex, or Mimir for extended historical data.
		- **Security**:
			- Enable TLS or a reverse proxy for the Prometheus and exporters endpoints if publicly exposed.
			- Restrict write/administrative access carefully to prevent malicious metric injection.
	- **Conclusion**:
		- **Prometheus** is a cornerstone for modern observability, especially in containerized or microservice environments like [[Kubernetes]].
		- The pull-based metrics collection, combined with PromQL and integrated alerting, provides a flexible monitoring solution.
		- By pairing Prometheus with tools like #Grafana for visualization and best practices around labeling and alert management, you can build a robust, scalable monitoring ecosystem.
- **Installing Prometheus on a Linux Server**
	- **Overview**:
		- **Prometheus** is distributed as precompiled binaries for various operating systems, including Linux.
		- A typical setup involves creating a dedicated Prometheus user, placing configuration files in standard locations, and running Prometheus as a service (e.g., via `systemd`).
		  
		  ---
	- **1. Download and Extract**
		- **Definition**:
			- Prometheus provides official binaries. You can download them from the [Prometheus releases page](https://github.com/prometheus/prometheus/releases) or use package managers if available.
		- **Example Steps** (using wget and tar):
		  ```bash
		  # 1. Fetch the latest release (example version: 2.41.0)
		  wget https://github.com/prometheus/prometheus/releases/download/v2.41.0/prometheus-2.41.0.linux-amd64.tar.gz
		  
		  # 2. Extract the tarball
		  tar xvf prometheus-2.41.0.linux-amd64.tar.gz
		  
		  # 3. Move binaries to /usr/local/bin
		  cd prometheus-2.41.0.linux-amd64
		  sudo mv prometheus /usr/local/bin/
		  sudo mv promtool /usr/local/bin/
		  
		  # 4. Move console libraries and templates (optional if you want default console pages)
		  sudo mkdir -p /etc/prometheus
		  sudo mv consoles /etc/prometheus/
		  sudo mv console_libraries /etc/prometheus/
		  ```
			- Adjust version numbers and paths to your environment.
			  
			  ---
	- **2. User and Directories**
		- **Definition**:
			- Create a dedicated user/group for running Prometheus to adhere to the principle of least privilege.
		- **Example**:
		  ```bash
		  # Create a prometheus user (no shell, no home directory)
		  sudo useradd --no-create-home --shell /usr/sbin/nologin prometheus
		  
		  # Create directories for configuration and data
		  sudo mkdir -p /etc/prometheus
		  sudo mkdir -p /var/lib/prometheus
		  
		  # Set ownership
		  sudo chown -R prometheus:prometheus /etc/prometheus
		  sudo chown -R prometheus:prometheus /var/lib/prometheus
		  ```
		  
		  ---
	- **3. Configuration (`prometheus.yml`)**
		- **Definition**:
			- The main configuration file defines global settings, scrape intervals, and scrape targets.
		- **Basic Example**:
		  ```yaml
		  global:
		    scrape_interval: 15s
		    evaluation_interval: 15s
		  
		  scrape_configs:
		  - job_name: "node_exporter"
		    static_configs:
		    - targets: ["localhost:9100"]
		  ```
			- Place this file in `/etc/prometheus/prometheus.yml`.
			- **Key Directives**:
				- `scrape_interval`: How often Prometheus scrapes each target.
				- `scrape_configs`: Specifies endpoints (targets) to scrape.
		- **Set Ownership**:
		  ```bash
		  sudo mv prometheus.yml /etc/prometheus/prometheus.yml
		  sudo chown prometheus:prometheus /etc/prometheus/prometheus.yml
		  ```
		  
		  ---
	- **4. Running Prometheus as a Service (systemd)**
		- **Definition**:
			- Using a systemd service file ensures Prometheus starts on boot and can be managed via `systemctl`.
		- **Example service file** (`/etc/systemd/system/prometheus.service`):
		  ```ini
		  [Unit]
		  Description=Prometheus Monitoring
		  Wants=network-online.target
		  After=network-online.target
		  
		  [Service]
		  User=prometheus
		  Group=prometheus
		  Type=simple
		  ExecStart=/usr/local/bin/prometheus \
		    --config.file=/etc/prometheus/prometheus.yml \
		    --storage.tsdb.path=/var/lib/prometheus/ \
		    --web.console.templates=/etc/prometheus/consoles \
		    --web.console.libraries=/etc/prometheus/console_libraries
		  Restart=on-failure
		  
		  [Install]
		  WantedBy=multi-user.target
		  ```
			- **Key Flags**:
				- `--config.file`: Path to your `prometheus.yml`.
				- `--storage.tsdb.path`: Directory where metrics data is stored.
				- `--web.console.*`: Paths to optional web console templates/libraries.
		- **Reload and Start**:
		  ```bash
		  sudo systemctl daemon-reload
		  sudo systemctl enable prometheus
		  sudo systemctl start prometheus
		  
		  # Check status
		  systemctl status prometheus
		  ```
		- **Verify**:
			- By default, Prometheus listens on port `9090`.
			- You can access the web UI at:  
			  ```plaintext
			  http://<server-ip>:9090
			  ```
			  
			  ---
	- **5. Validating Installation**
		- **Local Host Check**:
			- `curl http://localhost:9090/metrics` to see raw metrics.
			- `curl http://localhost:9090/-/healthy` for a quick health check.
		- **Web UI**:
			- Access the Prometheus expression browser at `<server-ip>:9090/graph`.
			- Explore default metrics like `up` to confirm the scrape is working.
			  
			  ---
	- **6. Basic Security Considerations**
		- **Access Control**:
			- Out of the box, Prometheus has no authentication/authorization.
			- Use a reverse proxy (e.g., Nginx, Apache) or OAuth proxy if you need authentication.
		- **Firewall**:
			- Restrict access to port `9090` to trusted networks/IP addresses.
		- **TLS Encryption**:
			- Prometheus can run behind a reverse proxy that terminates TLS if you require HTTPS.
			  
			  ---
	- **7. Next Steps**:
		- **Add Exporters**:
			- For node metrics, install **Node Exporter** on the same or other servers (listening on port `9100` by default).
			- Update `prometheus.yml` to scrape those endpoints.
		- **Set Up Alertmanager**:
			- Configure alerting rules in `prometheus.yml`.
			- Install and configure Alertmanager to handle alert routing.
		- **Dashboarding**:
			- Install #Grafana and connect it to Prometheus for a richer visualization experience.
		- **Scale / HA**:
			- Consider using multiple Prometheus instances for high availability or explore long-term storage solutions (Thanos, Cortex, etc.).
			  
			  ---
	- **8. Automatic script example**
		- ```
		  #!/usr/bin/env bash
		  #--------------------------------------------------------------------
		  # Script to Install Prometheus Server on Linux (Ubuntu/CentOS)
		  # Tested on Ubuntu 22.04, 24.04
		  # Developed by [Van] in 2025
		  #--------------------------------------------------------------------
		  
		  # Variables
		  PROMETHEUS_VERSION="2.51.1"
		  PROMETHEUS_USER="prometheus"
		  PROMETHEUS_GROUP="prometheus"
		  PROMETHEUS_FOLDER_CONFIG="/etc/prometheus"
		  PROMETHEUS_FOLDER_TSDATA="/etc/prometheus/data"
		  PROMETHEUS_BIN="/usr/bin/prometheus"
		  SYSTEMD_SERVICE_PATH="/etc/systemd/system/prometheus.service"
		  DOWNLOAD_URL="https://github.com/prometheus/prometheus/releases/download/v${PROMETHEUS_VERSION}/prometheus-${PROMETHEUS_VERSION}.linux-amd64.tar.gz"
		  
		  # Colors for output
		  GREEN="\033[0;32m"
		  RED="\033[0;31m"
		  RESET="\033[0m"
		  
		  echo -e "${GREEN}--- Installing Prometheus v${PROMETHEUS_VERSION} ---${RESET}"
		  
		  # 1. Update system packages (Uncomment if desired)
		  # echo "Updating package list..."
		  # sudo apt-get update -y
		  
		  # 2. Create Prometheus user if it does not exist
		  if ! id -u "$PROMETHEUS_USER" > /dev/null 2>&1; then
		    echo "Creating Prometheus user and group..."
		    useradd -rs /bin/false "$PROMETHEUS_USER"
		  else
		    echo "User '$PROMETHEUS_USER' already exists. Skipping user creation."
		  fi
		  
		  # 3. Download and extract Prometheus
		  echo "Downloading Prometheus from ${DOWNLOAD_URL}"
		  cd /tmp || exit 1
		  wget -q "$DOWNLOAD_URL"
		  if [ $? -ne 0 ]; then
		    echo -e "${RED}Failed to download Prometheus. Check your network or version.${RESET}"
		    exit 1
		  fi
		  
		  tar xvfz "prometheus-${PROMETHEUS_VERSION}.linux-amd64.tar.gz"
		  cd "prometheus-${PROMETHEUS_VERSION}.linux-amd64" || exit 1
		  
		  # 4. Move Prometheus binary to /usr/bin
		  echo "Installing Prometheus binary to ${PROMETHEUS_BIN}"
		  mv prometheus /usr/bin/
		  chmod +x "$PROMETHEUS_BIN"
		  
		  # 5. Cleanup extracted files
		  echo "Cleaning up /tmp..."
		  rm -rf "/tmp/prometheus-${PROMETHEUS_VERSION}*" 
		  
		  # 6. Create necessary directories
		  echo "Creating configuration and data directories..."
		  mkdir -p "$PROMETHEUS_FOLDER_CONFIG"
		  mkdir -p "$PROMETHEUS_FOLDER_TSDATA"
		  
		  # 7. Create a basic prometheus.yml file
		  echo "Creating Prometheus config: $PROMETHEUS_FOLDER_CONFIG/prometheus.yml"
		  cat <<EOF > "${PROMETHEUS_FOLDER_CONFIG}/prometheus.yml"
		  global:
		    scrape_interval: 15s
		  
		  scrape_configs:
		    - job_name: "prometheus"
		      static_configs:
		        - targets: ["localhost:9090"]
		  EOF
		  
		  # 8. Set ownership and permissions
		  echo "Setting ownership and permissions..."
		  chown -R "${PROMETHEUS_USER}:${PROMETHEUS_GROUP}" "$PROMETHEUS_BIN"
		  chown -R "${PROMETHEUS_USER}:${PROMETHEUS_GROUP}" "$PROMETHEUS_FOLDER_CONFIG"
		  chown -R "${PROMETHEUS_USER}:${PROMETHEUS_GROUP}" "$PROMETHEUS_FOLDER_TSDATA"
		  
		  # 9. Create systemd service file
		  echo "Creating systemd service at $SYSTEMD_SERVICE_PATH"
		  cat <<EOF > "$SYSTEMD_SERVICE_PATH"
		  [Unit]
		  Description=Prometheus Server
		  After=network.target
		  
		  [Service]
		  User=${PROMETHEUS_USER}
		  Group=${PROMETHEUS_GROUP}
		  Type=simple
		  Restart=on-failure
		  ExecStart=${PROMETHEUS_BIN} \\
		    --config.file=${PROMETHEUS_FOLDER_CONFIG}/prometheus.yml \\
		    --storage.tsdb.path=${PROMETHEUS_FOLDER_TSDATA}
		  
		  [Install]
		  WantedBy=multi-user.target
		  EOF
		  
		  # 10. Reload systemd and start Prometheus
		  echo "Reloading systemd daemon and enabling Prometheus service..."
		  systemctl daemon-reload
		  systemctl enable prometheus
		  systemctl start prometheus
		  
		  # 11. Check Prometheus service status
		  echo "Checking Prometheus service status..."
		  systemctl status prometheus --no-pager
		  
		  # 12. Display Prometheus version
		  echo -e "\n${GREEN}Prometheus version:${RESET}"
		  prometheus --version
		  ```
	- **Conclusion**:
		- Installing Prometheus on Linux involves downloading the binaries, setting up a dedicated user, configuring the `prometheus.yml`, and managing Prometheus as a systemd service.
		- Once running, you can scrape metrics from local or remote exporters and start building your observability stack with alerting, dashboards, and expansions to monitor your entire environment.
- **Installing Node Exporter on Linux Servers**
	- **Overview**:
		- **Node Exporter** is a Prometheus exporter that collects hardware and OS metrics from Linux servers.
		- It exposes key system metrics (CPU, memory, disk, network, etc.) via an HTTP endpoint (default port 9100).
		- These metrics are used by Prometheus to monitor server health and performance.
		- Installing Node Exporter on your servers provides a standardized view of your infrastructure’s resource usage.
	- **Installation Steps Overview**:
		- 1. **Download and Extract**:
			- Retrieve the appropriate Node Exporter release from its [GitHub releases page](https://github.com/prometheus/node_exporter/releases).
			- Extract the tarball.
		- 2. **Install Binary**:
			- Move the `node_exporter` binary to `/usr/bin/` for system-wide access.
		- 3. **Create a Dedicated User**:
			- Create a system user (without a login shell) to run Node Exporter securely.
		- 4. **Configure systemd Service**:
			- Create a systemd service file to manage the Node Exporter process.
			- Enable and start the service to ensure it launches on boot.
		- 5. **Verification**:
			- Check the status of the service.
			- Verify that Node Exporter is running and confirm its version.
	- **Automated Installation Script**:
		- Below is a bash script that automates all the above steps. You can save this script (e.g., as `install_node_exporter.sh`), make it executable, and run it on your Linux server.
		  
		  ```bash
		  #!/bin/bash
		  #--------------------------------------------------------------------
		  # Script to Install Prometheus Node_Exporter on Linux
		  # Tested on Ubuntu 24.04
		  #--------------------------------------------------------------------
		  # https://github.com/prometheus/node_exporter/releases
		  NODE_EXPORTER_VERSION="1.9.0"
		  
		  cd /tmp
		  wget https://github.com/prometheus/node_exporter/releases/download/v$NODE_EXPORTER_VERSION/node_exporter-$NODE_EXPORTER_VERSION.linux-amd64.tar.gz
		  tar xvfz node_exporter-$NODE_EXPORTER_VERSION.linux-amd64.tar.gz
		  cd node_exporter-$NODE_EXPORTER_VERSION.linux-amd64
		  
		  mv node_exporter /usr/bin/
		  rm -rf /tmp/node_exporter*
		  
		  useradd -rs /bin/false node_exporter
		  chown node_exporter:node_exporter /usr/bin/node_exporter
		  
		  
		  cat <<EOF> /etc/systemd/system/node_exporter.service
		  [Unit]
		  Description=Prometheus Node Exporter
		  After=network.target
		  
		  [Service]
		  User=node_exporter
		  Group=node_exporter
		  Type=simple
		  Restart=on-failure
		  ExecStart=/usr/bin/node_exporter
		  
		  [Install]
		  WantedBy=multi-user.target
		  EOF
		  
		  systemctl daemon-reload
		  systemctl start node_exporter
		  systemctl enable node_exporter
		  systemctl status node_exporter
		  node_exporter --version
		  ```
	- **Post-Installation**:
		- Once the script runs successfully, Node Exporter will be installed and running as a systemd service.
		- By default, it listens on port **9100**. Ensure that your firewall settings allow access to this port if needed.
		- Configure your Prometheus server to scrape metrics from this endpoint by adding a new job in your Prometheus configuration:
		  ```yaml
		  scrape_configs:
		    - job_name: 'node_exporter'
		      static_configs:
		        - targets: ['<server-ip>:9100']
		  ```
	- **Conclusion**:
		- This script automates the installation and setup of Node Exporter on a Linux server.
		- With Node Exporter running, you can now integrate it with Prometheus to monitor your server's health and performance.
		- The standardized setup helps maintain consistency across multiple servers and simplifies future maintenance.
- **Installing Windows Exporter on Windows Servers**
	- **Overview**:
		- **Windows Exporter** (formerly known as WMI Exporter) is the Prometheus exporter for Windows, which collects and exposes various Windows metrics (e.g., CPU, memory, disk, network) for monitoring.
		- It is essential for integrating Windows servers into a Prometheus-based monitoring system.
		- This exporter enables you to collect system-level metrics from Windows Server 2019, 2022, and other supported versions.
	- **Why Use Windows Exporter?**:
		- **Standardized Monitoring**: Provides a consistent way to monitor Windows servers alongside Linux nodes.
		- **Integration with Prometheus**: Metrics exposed by Windows Exporter can be scraped by Prometheus and visualized using tools like Grafana.
		- **Automated Deployment**: Using scripts and MSI packages simplifies the installation process, ensuring repeatable and reliable deployments.
	- **Installation Steps Overview**:
		- 1. **Download the Installer**:
			- Retrieve the appropriate MSI package from the [Prometheus Community Windows Exporter Releases](https://github.com/prometheus-community/windows_exporter/releases).
		- 2. **Install the Exporter**:
			- Run the MSI installer silently using PowerShell and `msiexec.exe` to avoid manual intervention.
		- 3. **Clean Up**:
			- Remove the downloaded MSI file after installation.
		- 4. **Verify the Service**:
			- Check that the Windows Exporter service is running and configured properly.
	- **Automated Installation Script**:
		- Below is a PowerShell script that automates the installation process on Windows servers.
		- Save the script (e.g., as `Install-WindowsExporter.ps1`), then run it with appropriate privileges.
		  
		  ```powershell
		  #--------------------------------------------------------------------
		  # PowerShell Script to Install Prometheus Windows_Exporter on Windows
		  # Tested on Windows Server 2019, 2022
		  #--------------------------------------------------------------------
		  # https://github.com/prometheus-community/windows_exporter/releases
		  $WINDOWS_EXPORTER_VERSION="0.25.1"
		  $URL="https://github.com/prometheus-community/windows_exporter/releases/download/v$WINDOWS_EXPORTER_VERSION/windows_exporter-$WINDOWS_EXPORTER_VERSION-amd64.msi"
		  
		  Invoke-WebRequest $URL -OutFile window_exporter.msi
		  Start-Process "msiexec.exe" -ArgumentList "/i window_exporter.msi /qn" -Wait
		  Remove-Item window_exporter.msi
		  Get-Service windows_exporter
		  ```
	- **Script Explanation**:
		- **Downloading**:
			- The script uses `Invoke-WebRequest` to download the MSI package for the specified version.
		- **Installation**:
			- It installs the MSI package silently (`/qn` flag) using `msiexec.exe` to avoid pop-up dialogs.
		- **Cleanup**:
			- After installation, the MSI file is deleted to free up disk space.
		- **Verification**:
			- Finally, the script retrieves the status of the `windows_exporter` service with `Get-Service` to confirm the installation.
	- **Conclusion**:
		- This automated PowerShell script simplifies the deployment of Windows Exporter on Windows servers.
		- Once installed, Windows Exporter will expose metrics (typically on port 9182) that can be scraped by Prometheus.
		- Integrate these metrics into your monitoring stack to gain comprehensive visibility into your Windows environment.
- **Installing and Configuring Prometheus Alertmanager**
	- **Overview**:
		- **Alertmanager** is the Prometheus component responsible for handling alerts sent by Prometheus.
		- It receives alerts from Prometheus, then applies logic like **grouping**, **deduplication**, **routing**, **inhibition**, and **silences**.
		- After processing, Alertmanager delivers notifications to configured receivers (e.g., **Slack**, **Email**, **Telegram**, **Webhooks**).
		- Alertmanager also provides a Web UI (default port **9093**) for viewing active alerts and managing silences.
	- **Key Concepts (must know)**:
		- **Alert (in Prometheus)**: rule that triggers when an expression is true for some time (`for:`).
		- **Labels**: metadata used for routing (e.g., `severity`, `team`, `service`, `env`).
		- **Annotations**: human-readable text (summary/description) included in notifications.
		- **Route**: decision tree that chooses which receiver should handle an alert.
		- **Receiver**: notification target configuration (Slack/email/webhook/etc.).
		- **Grouping**: bundling similar alerts into one message.
		- **Deduplication**: preventing repeated identical notifications.
		- **Inhibition**: suppressing “less important” alerts when a “more important” alert is firing.
		- **Silence**: manually muting alerts matching matchers for a time window.
	- **Installation Steps Overview**:
		- **Download and Extract**:
			- Retrieve the Alertmanager release from its GitHub releases page.
			- Extract the tarball and copy `alertmanager` + `amtool` binaries.
		- **Create Dedicated User and Directories**:
			- Create a system user to run Alertmanager securely.
			- Prepare config and data directories.
		- **Configure Alertmanager YAML**:
			- Define routes, receivers, and (optionally) inhibition rules.
		- **Configure systemd Service**:
			- Create a systemd unit to manage Alertmanager.
			- Enable and start the service to launch at boot.
		- **Connect Prometheus to Alertmanager**:
			- Add alertmanager target(s) into `prometheus.yml`.
		- **Verification**:
			- Check service status and UI availability.
			- Validate config with `amtool check-config`.
	- **Automated Installation Script (systemd, Ubuntu/Debian)**:
		- Save as `install_alertmanager.sh`, `chmod +x`, run as root.
		  
		  ```
		  #!/bin/bash
		  #--------------------------------------------------------------------
		  # Script to Install Prometheus Alertmanager on Linux (systemd)
		  # Tested on Ubuntu/Debian
		  #--------------------------------------------------------------------
		  # https://github.com/prometheus/alertmanager/releases
		  ALERTMANAGER_VERSION="0.28.0"
		  AM_USER="alertmanager"
		  AM_BIN_DIR="/usr/bin"
		  AM_CFG_DIR="/etc/alertmanager"
		  AM_DATA_DIR="/var/lib/alertmanager"
		  AM_LISTEN="0.0.0.0:9093"
		  
		  set -e
		  
		  apt-get update
		  apt-get install -y wget tar
		  
		  # Create user (no login shell)
		  if ! id "${AM_USER}" >/dev/null 2>&1; then
		  useradd -rs /bin/false "${AM_USER}"
		  fi
		  
		  # Create directories
		  mkdir -p "${AM_CFG_DIR}" "${AM_DATA_DIR}"
		  chown -R "${AM_USER}:${AM_USER}" "${AM_CFG_DIR}" "${AM_DATA_DIR}"
		  
		  # Download and install binaries
		  cd /tmp
		  wget -q https://github.com/prometheus/alertmanager/releases/download/v${ALERTMANAGER_VERSION}/alertmanager-${ALERTMANAGER_VERSION}.linux-amd64.tar.gz
		  tar xvfz alertmanager-${ALERTMANAGER_VERSION}.linux-amd64.tar.gz
		  
		  cp alertmanager-${ALERTMANAGER_VERSION}.linux-amd64/alertmanager "${AM_BIN_DIR}/alertmanager"
		  cp alertmanager-${ALERTMANAGER_VERSION}.linux-amd64/amtool "${AM_BIN_DIR}/amtool"
		  
		  chown "${AM_USER}:${AM_USER}" "${AM_BIN_DIR}/alertmanager" "${AM_BIN_DIR}/amtool"
		  chmod 755 "${AM_BIN_DIR}/alertmanager" "${AM_BIN_DIR}/amtool"
		  
		  rm -rf /tmp/alertmanager*
		  
		  # Minimal config (webhook placeholder)
		  if [ ! -f "${AM_CFG_DIR}/alertmanager.yml" ]; then
		  cat <<EOF > "${AM_CFG_DIR}/alertmanager.yml"
		  global:
		  resolve_timeout: 5m
		  
		  route:
		  receiver: "default"
		  group_by: ["alertname", "instance", "service"]
		  group_wait: 30s
		  group_interval: 5m
		  repeat_interval: 4h
		  
		  receivers:
		  - name: "default"
		  webhook_configs:
		    - url: "http://127.0.0.1:5001/alert"
		  EOF
		  fi
		  
		  chown "${AM_USER}:${AM_USER}" "${AM_CFG_DIR}/alertmanager.yml"
		  
		  # systemd unit
		  cat <<EOF > /etc/systemd/system/alertmanager.service
		  [Unit]
		  Description=Prometheus Alertmanager
		  After=network-online.target
		  Wants=network-online.target
		  
		  [Service]
		  User=${AM_USER}
		  Group=${AM_USER}
		  Type=simple
		  Restart=on-failure
		  RestartSec=3
		  ExecStart=${AM_BIN_DIR}/alertmanager \\
		  --config.file=${AM_CFG_DIR}/alertmanager.yml \\
		  --storage.path=${AM_DATA_DIR} \\
		  --web.listen-address=${AM_LISTEN}
		  
		  [Install]
		  WantedBy=multi-user.target
		  EOF
		  
		  systemctl daemon-reload
		  systemctl enable --now alertmanager
		  systemctl status alertmanager --no-pager
		  
		  # Validate config
		  amtool check-config ${AM_CFG_DIR}/alertmanager.yml
		  alertmanager --version
		  ```
		- **Post-Installation**:
			- Alertmanager UI should be available at:
				- `http://<server-ip>:9093`
			- Default stateful storage path:
				- `/var/lib/alertmanager` (silences, notification log, etc.)
			- Validate config anytime after edits:
			  
			  ```
			  amtool check-config /etc/alertmanager/alertmanager.yml
			  sudo systemctl restart alertmanager
			  ```
		- **Connecting Prometheus → Alertmanager**:
			- In `prometheus.yml`:
			  
			  ```
			  alerting:
			  alertmanagers:
			  - static_configs:
			      - targets: ['<alertmanager-ip>:9093']
			  ```
			- Then reload/restart Prometheus and confirm in Prometheus UI:
				- **Status → Alertmanagers** should show Alertmanager as UP.
		- **Example Alert Rule (Prometheus side)**:
			- File: `rules/alerts.yml`
			  
			  ```
			  groups:
			  - name: base_alerts
			  rules:
			    - alert: InstanceDown
			      expr: up == 0
			      for: 2m
			      labels:
			        severity: critical
			        team: ops
			        service: infra
			      annotations:
			        summary: "Instance down: {{ $labels.instance }}"
			        description: "Target is unreachable for > 2 minutes."
			  ```
			- Important:
				- `labels` drive routing in Alertmanager.
				- `annotations` become the human message content.
		- **Alertmanager Routing + Receivers (practical examples)**:
			- **Routing by severity/team**:
			  
			  ```
			  route:
			  receiver: "default"
			  group_by: ["alertname", "instance", "service"]
			  group_wait: 30s
			  group_interval: 5m
			  repeat_interval: 4h
			  
			  routes:
			  - matchers:
			      - severity="critical"
			    receiver: "ops-critical"
			    repeat_interval: 30m
			  
			  - matchers:
			      - team="dev"
			    receiver: "dev-team"
			  ```
			- **Slack receiver example**:
			  
			  ```
			  receivers:
			  - name: "ops-critical"
			  slack_configs:
			    - api_url: "https://hooks.slack.com/services/XXX/YYY/ZZZ"
			      channel: "#ops-alerts"
			      title: "[{{ .Status | toUpper }}] {{ .CommonLabels.alertname }}"
			      text: >-
			        {{ range .Alerts -}}
			        *{{ .Labels.instance }}* — {{ .Annotations.summary }}
			        {{ end }}
			  ```
			- **Email receiver example**:
			  
			  ```
			  receivers:
			  - name: "dev-team"
			  email_configs:
			    - to: "dev-team@example.com"
			      from: "alertmanager@example.com"
			      smarthost: "smtp.example.com:587"
			      auth_username: "alertmanager@example.com"
			      auth_password: "CHANGE_ME"
			      require_tls: true
			  ```
		- **Inhibition Rules (reduce noise)**:
			- If the host is down, suppress warning alerts from the same instance:
			  
			  ```
			  inhibit_rules:
			  - source_matchers:
			    - alertname="InstanceDown"
			    - severity="critical"
			  target_matchers:
			    - severity="warning"
			  equal: ["instance"]
			  ```
		- **Silences (maintenance mode)**:
			- Create silence via CLI:
			  
			  ```
			  amtool --alertmanager.url=http://localhost:9093 silence add \
			  alertname="InstanceDown" instance="node-1:9100" \
			  --duration="2h" \
			  --comment="maintenance" \
			  --author="dmitry"
			  ```
			- Or via UI:
				- `http://<server-ip>:9093` → **Silences** → **New Silence**
		- **Best Practices & Tips**:
			- Use consistent labels in all alerts: `severity`, `team`, `service`, `env`, `cluster`.
			- Start simple:
				- 1 default receiver + 1–2 routing rules, then extend gradually.
			- Tune spam control:
				- `group_wait` (batching), `group_interval` (update frequency), `repeat_interval` (reminder frequency).
			- Use inhibition to avoid cascades during outages.
			- Don’t store tokens/passwords in git:
				- keep them in secrets/env or protected config locations.
		- **Conclusion**:
			- Alertmanager turns Prometheus alerts into actionable notifications: it routes them, groups them, deduplicates them, and suppresses noise.
			- With proper labels + routing rules + inhibition, you get fewer messages and faster response times.
			- Add receivers and routes step-by-step as your infrastructure and teams grow.
- **Grafana: Installation, Data Source Setup, and Dashboard Integration**
	- #Grafana
	- **Overview**:
		- Grafana is an open-source platform for monitoring and observability that allows you to create interactive, customizable dashboards.
		- It integrates with various data sources, with Prometheus being one of the most popular.
		- Dashboards can be imported from the Grafana.com repository or created from scratch.
		  
		  ---
	- **1. Installing Grafana**
		- **Using Package Manager (Ubuntu Example)**:
		  1. **Add the Grafana APT repository**:
		     ```bash
		     sudo apt-get install -y software-properties-common
		     sudo add-apt-repository "deb https://packages.grafana.com/oss/deb stable main"
		     wget -q -O - https://packages.grafana.com/gpg.key | sudo apt-key add -
		     sudo apt-get update
		     ```
		  2. **Install Grafana**:
		     ```bash
		     sudo apt-get install grafana -y
		     ```
		  3. **Enable and start the Grafana service**:
		     ```bash
		     sudo systemctl enable grafana-server
		     sudo systemctl start grafana-server
		     ```
		- **Default Access**:
			- Grafana’s web interface is available at: [http://<server-ip>:3000](http://<server-ip>:3000)
			- Default login is typically **admin/admin** (Grafana will prompt to change the password on first login).
			  
			  ---
		- install_grafana_server_ubuntu script
			- ```
			  #!/bin/bash
			  #--------------------------------------------------------------------
			  # Script to Install Grafana Server on Linux Ubuntu (22.04, 24.04)
			  # Include Prometheus DataSource Configuration
			  #--------------------------------------------------------------------
			  # https://grafana.com/grafana/download
			  GRAFANA_VERSION="11.6.0"
			  PROMETHEUS_URL="http://localhost:9090"
			  
			  
			  apt-get install -y apt-transport-https software-properties-common wget
			  mkdir -p /etc/apt/keyrings/
			  wget -q -O - https://apt.grafana.com/gpg.key | gpg --dearmor | sudo tee /etc/apt/keyrings/grafana.gpg > /dev/null
			  echo "deb [signed-by=/etc/apt/keyrings/grafana.gpg] https://apt.grafana.com stable main" | sudo tee -a /etc/apt/sources.list.d/grafana.list
			  apt-get update
			  apt-get install -y adduser libfontconfig1 musl
			  
			  wget https://dl.grafana.com/oss/release/grafana_${GRAFANA_VERSION}_amd64.deb
			  dpkg -i grafana_${GRAFANA_VERSION}_amd64.deb
			  
			  echo "export PATH=/usr/share/grafana/bin:$PATH" >> /etc/profile
			  
			  
			  cat <<EOF> /etc/grafana/provisioning/datasources/prometheus.yaml
			  apiVersion: 1
			  
			  datasources:
			    - name: Prometheus
			      type: prometheus
			      url: ${PROMETHEUS_URL}
			  EOF
			  
			  systemctl daemon-reload
			  systemctl enable grafana-server
			  systemctl start grafana-server
			  systemctl status grafana-server
			  ```
	- **2. Configuring Data Source**
		- **Adding Prometheus as a Data Source**:
		  1. **Login to Grafana**: Open the web interface.
		  2. **Navigate to Data Sources**: Click on **Gear Icon (Configuration)** > **Data Sources**.
		  3. **Add Data Source**: Click **Add data source**.
		  4. **Select Prometheus**:
			- In the data source settings, set the URL to your Prometheus server (e.g., `http://<prometheus-ip>:9090`).
			- Adjust other settings as needed (access mode, scrape interval, etc.).
			  5. **Save & Test**: Click the **Save & Test** button to verify the connection.
			  
			  ---
	- **3. Adding Dashboards**
		- **Importing a Pre-Built Dashboard**:
		  1. **Navigate to Dashboards**: Click on the **+** icon > **Import**.
		  2. **Enter Dashboard ID**:
			- You can find dashboard IDs on [Grafana.com Dashboards](https://grafana.com/grafana/dashboards).
			- Enter an ID (e.g., `1860` for a popular Prometheus dashboard) and click **Load**.
			  3. **Select Data Source**: Choose your Prometheus data source from the dropdown.
			  4. **Import Dashboard**: Click **Import** to add the dashboard.
		- **Creating a Custom Dashboard**:
		  1. **Start a New Dashboard**: Click **+ Create** > **Dashboard**.
		  2. **Add Panels**:
			- Click **Add new panel**.
			- Write PromQL queries in the query editor to visualize metrics.
			- Configure visualization options (graphs, singlestat, heatmaps, etc.).
			  3. **Save Dashboard**:
			- Give the dashboard a name.
			- Optionally, add tags and set sharing options.
			  
			  ---
	- **Best Practices & Tips**:
		- **Organize Dashboards**: Group dashboards by environment or service to make navigation easier.
		- **Dashboard Variables**: Use variables to create dynamic dashboards that let users select different servers, regions, or time intervals.
		- **Alerting**: Grafana supports setting up alerts on panels, which can be sent via email, Slack, or other channels.
		- **Backup Configurations**: Regularly export your dashboards and configuration settings for disaster recovery.
		  
		  ---
	- **Conclusion**:
		- By installing Grafana, configuring Prometheus as a data source, and setting up dashboards, you create a powerful monitoring and visualization system.
		- This setup enhances observability by providing real-time insights into your infrastructure's performance.
		- Customize and expand dashboards over time to meet the evolving needs of your monitoring strategy.
- **Prometheus - How to Monitor a Dynamic Number of Servers on AWS**
	- **Overview**:
		- In cloud environments like AWS, the number of servers (EC2 instances) can change dynamically due to auto-scaling, spot instances, and ephemeral workloads.
		- Prometheus supports dynamic service discovery, which enables it to automatically detect and scrape metrics from new instances as they come online, without manual intervention.
		- The key is leveraging AWS service discovery mechanisms within Prometheus, such as **EC2 service discovery (ec2_sd_configs)**, which can filter instances based on tags, regions, or instance states.
	- **Dynamic Environments on AWS**:
		- **Auto Scaling Groups (ASG)**: Automatically adjusts the number of running instances based on demand.
		- **Ephemeral Instances**: Instances can be short-lived (e.g., for batch jobs or spot instances).
		- **Tag-Based Organization**: Instances are tagged with metadata (like `Environment`, `Role`, or `Service`) to identify which ones should be monitored.
		- **Elasticity**: Monitoring solutions must adapt to frequent changes in infrastructure without requiring manual configuration updates.
	- **AWS Service Discovery in Prometheus**:
		- Prometheus can discover AWS EC2 instances automatically using the `ec2_sd_configs` configuration in its `prometheus.yml` file.
		- **Key Elements**:
			- **Filters**: Use filters to select only the relevant instances (e.g., by tag or instance state).
			- **Region**: Specify the AWS region(s) to search for instances.
			- **Refresh Interval**: Set how often Prometheus should poll AWS for instance changes.
	- **Example Configuration**:
		- A sample `prometheus.yml` snippet using AWS EC2 service discovery:
		  ```yaml
		  global:
		    scrape_interval: 15s
		    evaluation_interval: 15s
		  
		  scrape_configs:
		    - job_name: 'aws_ec2'
		      ec2_sd_configs:
		        - region: us-east-1
		          access_key: YOUR_AWS_ACCESS_KEY   # Optional if running on EC2 with proper IAM role
		          secret_key: YOUR_AWS_SECRET_KEY   # Optional if running on EC2 with proper IAM role
		          port: 9100
		          filters:
		            - name: tag:Monitoring
		              values: ["prometheus"]
		            - name: instance-state-name
		              values: ["running"]
		      relabel_configs:
		        - source_labels: [__meta_ec2_tag_Service]
		          target_label: service
		        - source_labels: [__meta_ec2_private_ip]
		          target_label: instance
		  ```
			- **Explanation**:
				- **`ec2_sd_configs`**: Instructs Prometheus to poll EC2 API for instances in the specified region.
				- **`filters`**: Only instances tagged with `Monitoring=prometheus` and in the running state are scraped.
				- **`relabel_configs`**: Map metadata (e.g., private IP, service tag) into labels used for queries and dashboards.
				- **Port**: Assumes that a node exporter or custom exporter is running on port **9100** on each instance.
	- **Advanced Considerations**:
		- **Multiple Regions**: If your infrastructure spans multiple regions, add additional `ec2_sd_configs` blocks for each region.
		- **Security and IAM**: Ensure Prometheus has the proper AWS IAM role or credentials to query EC2 metadata securely.
		- **Filtering for Specific Roles**: Use instance tags (e.g., `Role=webserver`) to narrow down the instances to monitor, reducing noise in your metrics.
		- **Relabeling for Consistency**: Customize relabeling rules to standardize labels across dynamic instances, which simplifies alerting and dashboard creation.
	- **Best Practices**:
		- **Tag Your Instances**: Standardize the use of tags across your AWS resources. For example, include a `Monitoring` tag to indicate whether an instance should be monitored.
		- **Automate Credentials**: If running Prometheus on an AWS instance, use an IAM role instead of hardcoding access keys.
		- **Monitor Scrape Failures**: Regularly review Prometheus targets to ensure that new instances are being discovered and scraped correctly.
		- **Scale Prometheus Appropriately**: For large-scale dynamic environments, consider federation or sharding strategies with Prometheus to manage high volumes of metrics.
		- **Integrate with Auto Scaling**: Leverage AWS Auto Scaling notifications or Lambda functions to adjust Prometheus configurations if necessary.
	- **Conclusion**:
		- By using AWS EC2 service discovery features in Prometheus, you can automatically monitor a dynamic number of servers on AWS.
		- This approach minimizes manual configuration, adapts to infrastructure changes in real time, and ensures that your monitoring system scales with your environment.
		- Combining proper tagging, secure IAM practices, and custom relabeling configurations results in a robust, automated monitoring setup suitable for dynamic cloud environments.